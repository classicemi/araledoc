## 前言
`Base`这个模块实际上才是Arale模块系统中对外的模块，它包含了之前介绍的Class类和Events类，以及自己内部的`attribute`模块和`aspect`模块，因此`Base`模块是真正的基础类。

## 带注释源码
`Base`源码的开头是这样的：
``` javascript
var Class = require('arale-class');
var Events = require('arale-events');
var Aspect = require('./aspect');
var Attribute = require('./attribute');
```
可见，整个`Base`的实现是基于上面这四个模块的，前两个模块已经分析过了，下面来分析后面两个模块。首先是`Aspect`模块，这个模块实际上只提供了两个方法`before`和`after`：
``` javascript
// `before`和`after`实际上是对`weave`方法的一次封装，提供易用的接口
// 在指定方法执行前，先执行 callback
exports.before = function(methodName, callback, context) {
  return weave.call(this, 'before', methodName, callback, context);
};

// 在指定方法执行后，再执行 callback
exports.after = function(methodName, callback, context) {
  return weave.call(this, 'after', methodName, callback, context);
};

// Helpers
// -------
// 事件分割
var eventSplitter = /\s+/;

/**
 * 控制callback的执行时序
 * @param  {String}   when       选择是`before`还是`after`
 * @param  {String}   methodName 方法名字符串
 * @param  {Function} callback   回调函数
 * @param  {Object}   context    上下文对象
 * @return {Object}              调用此方法的对象
 */
function weave(when, methodName, callback, context) {
  // 取得方法名数组
  var names = methodName.split(eventSplitter);
  var name, method;

  // 遍历方法名数组
  while (name = names.shift()) {
    // 取得方法函数
    method = getMethod(this, name);
    // 方法是否被改造过，如果没有则进行改造
    if (!method.__isAspected) {
      wrap.call(this, name);
    }
    // 绑定一下事件
    this.on(when + ':' + name, callback, context);
  }

  return this;
}

/**
 * 取得对应名称的方法
 * @param  {Object} host       调用对象
 * @param  {String} methodName 方法名称
 * @return {Function}            方法函数
 */
function getMethod(host, methodName) {
  // 取得对象上对应的方法函数
  var method = host[methodName];
  // 如果方法不存在则报错
  if (!method) {
    throw new Error('Invalid method name: ' + methodName);
  }
  return method;
}

/**
 * [wrap description]
 * @param  {[type]} methodName [description]
 * @return {[type]}            [description]
 */
function wrap(methodName) {
  // 取得对象上的方法
  var old = this[methodName];

  // 对方法进行改造封装
  // 改造过的方法执行时，会先触发'before:methodName'事件
  this[methodName] = function() {
    // 切分参数
    var args = Array.prototype.slice.call(arguments);
    // 在参数数组前添加一项'before:methodName'
    var beforeArgs = ['before:' + methodName].concat(args);

    // prevent if trigger return false
    // 先触发`before:methodName`事件，如果存在回调函数队列且执行后返回false，则阻止进一步往下执行
    if (this.trigger.apply(this, beforeArgs) === false) return;

    // 执行原方法，保存返回值
    var ret = old.apply(this, arguments);

    // 构造参数数组，执行`after:methodName`事件
    var afterArgs = ['after:' + methodName, ret].concat(args);
    this.trigger.apply(this, afterArgs);

    return ret;
  };

  // 修改方法是否被改造状态属性
  this[methodName].__isAspected = true;
}
```
下面是`Attribute`模块，该模块控制类的属性：
``` javascript
// 负责 attributes 的初始化
// attributes 是与实例相关的状态信息，可读可写，发生变化时，会自动触发相关事件
exports.initAttrs = function(config) {
  // initAttrs 是在初始化时调用的，默认情况下实例上肯定没有 attrs，不存在覆盖问题
  var attrs = this.attrs = {};

  // Get all inherited attributes.
  var specialProps = this.propsInAttrs || [];
  mergeInheritedAttrs(attrs, this, specialProps);

  // Merge user-specific attributes from config.
  if (config) {
    mergeUserValue(attrs, config);
  }

  // 对于有 setter 的属性，要用初始值 set 一下，以保证关联属性也一同初始化
  setSetterAttrs(this, attrs, config);

  // Convert `on/before/afterXxx` config to event handler.
  parseEventsFromAttrs(this, attrs);

  // 将 this.attrs 上的 special properties 放回 this 上
  copySpecialProps(specialProps, this, attrs, true);
};


// Get the value of an attribute.
exports.get = function(key) {
  var attr = this.attrs[key] || {};
  var val = attr.value;
  return attr.getter ? attr.getter.call(this, val, key) : val;
};


// Set a hash of model attributes on the object, firing `"change"` unless
// you choose to silence it.
exports.set = function(key, val, options) {
  var attrs = {};

  // set("key", val, options)
  if (isString(key)) {
    attrs[key] = val;
  }
  // set({ "key": val, "key2": val2 }, options)
  else {
    attrs = key;
    options = val;
  }

  options || (options = {});
  var silent = options.silent;
  var override = options.override;

  var now = this.attrs;
  var changed = this.__changedAttrs || (this.__changedAttrs = {});

  for (key in attrs) {
    if (!attrs.hasOwnProperty(key)) continue;

    var attr = now[key] || (now[key] = {});
    val = attrs[key];

    if (attr.readOnly) {
      throw new Error('This attribute is readOnly: ' + key);
    }

    // invoke setter
    if (attr.setter) {
      val = attr.setter.call(this, val, key);
    }

    // 获取设置前的 prev 值
    var prev = this.get(key);

    // 获取需要设置的 val 值
    // 如果设置了 override 为 true，表示要强制覆盖，就不去 merge 了
    // 都为对象时，做 merge 操作，以保留 prev 上没有覆盖的值
    if (!override && isPlainObject(prev) && isPlainObject(val)) {
      val = merge(merge({}, prev), val);
    }

    // set finally
    now[key].value = val;

    // invoke change event
    // 初始化时对 set 的调用，不触发任何事件
    if (!this.__initializingAttrs && !isEqual(prev, val)) {
      if (silent) {
        changed[key] = [val, prev];
      }
      else {
        this.trigger('change:' + key, val, prev, key);
      }
    }
  }

  return this;
};


// Call this method to manually fire a `"change"` event for triggering
// a `"change:attribute"` event for each changed attribute.
exports.change = function() {
  var changed = this.__changedAttrs;

  if (changed) {
    for (var key in changed) {
      if (changed.hasOwnProperty(key)) {
        var args = changed[key];
        this.trigger('change:' + key, args[0], args[1], key);
      }
    }
    delete this.__changedAttrs;
  }

  return this;
};

// for test
exports._isPlainObject = isPlainObject;

// Helpers
// -------

// `toString`方法引用
var toString = Object.prototype.toString;
// `hasOwnProperty`方法引用
var hasOwn = Object.prototype.hasOwnProperty;

// 检测在枚举对象属性的时候，非继承属性是否在继承属性之后被枚举，针对IE < 9
var iteratesOwnLast;
(function() {
  var props = [];
  function Ctor() { this.x = 1; }
  Ctor.prototype = { 'valueOf': 1, 'y': 1 };
  for (var prop in new Ctor()) { props.push(prop); }
  iteratesOwnLast = props[0] !== 'x';
}());

// 检测数组方法
var isArray = Array.isArray || function(val) {
  return toString.call(val) === '[object Array]';
};

// 检测字符串方法
function isString(val) {
  return toString.call(val) === '[object String]';
}

// 检测函数方法
function isFunction(val) {
  return toString.call(val) === '[object Function]';
}

// 检测一个对象是否是window对象
function isWindow(o) {
  return o != null && o == o.window;
}

// 检测是否为纯粹的对象(通过{}或new Object()创建的对象)方法，这里引用的是jQuery的方法，具体分析见后文
function isPlainObject(o) {
  if (!o || toString.call(o) !== "[object Object]" ||
      o.nodeType || isWindow(o)) {
    return false;
  }

  try {
    if (o.constructor &&
        !hasOwn.call(o, "constructor") &&
        !hasOwn.call(o.constructor.prototype, "isPrototypeOf")) {
      return false;
    }
  } catch (e) {
    return false;
  }

  var key;

  if (iteratesOwnLast) {
    for (key in o) {
      return hasOwn.call(o, key);
    }
  }

  for (key in o) {}

  return key === undefined || hasOwn.call(o, key);
}

// 检测是否为空对象，和`isPlainObject`相似，如果没有非继承属性，则是空对象
function isEmptyObject(o) {
  if (!o || toString.call(o) !== "[object Object]" ||
      o.nodeType || isWindow(o) || !o.hasOwnProperty) {
    return false;
  }

  for (var p in o) {
    if (o.hasOwnProperty(p)) return false;
  }
  return true;
}

// 用来合并两个对象的方法
function merge(receiver, supplier) {
  var key, value;

  for (key in supplier) {
    if (supplier.hasOwnProperty(key)) {
      receiver[key] = cloneValue(supplier[key], receiver[key]);
    }
  }

  return receiver;
}

// 只 clone 数组和 plain object，其他的保持不变
function cloneValue(value, prev){
  if (isArray(value)) {
    value = value.slice();
  }
  else if (isPlainObject(value)) {
    isPlainObject(prev) || (prev = {});

    value = merge(prev, value);
  }

  return value;
}

// 保存`Object.keys`引用
var keys = Object.keys;
// 不支持ES5的浏览器就自己实现，前文已述
if (!keys) {
  keys = function(o) {
    var result = [];

    for (var name in o) {
      if (o.hasOwnProperty(name)) {
        result.push(name);
      }
    }
    return result;
  };
}

/**
 * [mergeInheritedAttrs description]
 * @param  {[type]} attrs        [description]
 * @param  {[type]} instance     [description]
 * @param  {[type]} specialProps [description]
 * @return {[type]}              [description]
 */
function mergeInheritedAttrs(attrs, instance, specialProps) {
  var inherited = [];
  var proto = instance.constructor.prototype;

  // 遍历原型链上的所有类
  while (proto) {
    // 不要拿到 prototype 上的
    if (!proto.hasOwnProperty('attrs')) {
      proto.attrs = {};
    }

    // 将 proto 上的特殊 properties 放到 proto.attrs 上，以便合并
    copySpecialProps(specialProps, proto.attrs, proto);

    // 为空时不添加
    if (!isEmptyObject(proto.attrs)) {
      inherited.unshift(proto.attrs);
    }

    // 向上回溯一级
    proto = proto.constructor.superclass;
  }

  // Merge and clone default values to instance.
  for (var i = 0, len = inherited.length; i < len; i++) {
    mergeAttrs(attrs, normalize(inherited[i]));
  }
}

function mergeUserValue(attrs, config) {
  mergeAttrs(attrs, normalize(config, true), true);
}


function copySpecialProps(specialProps, receiver, supplier, isAttr2Prop) {
  for (var i = 0, len = specialProps.length; i < len; i++) {
    var key = specialProps[i];

    if (supplier.hasOwnProperty(key)) {
      receiver[key] = isAttr2Prop ? receiver.get(key) : supplier[key];
    }
  }
}


var EVENT_PATTERN = /^(on|before|after)([A-Z].*)$/;
var EVENT_NAME_PATTERN = /^(Change)?([A-Z])(.*)/;

function parseEventsFromAttrs(host, attrs) {
  for (var key in attrs) {
    if (attrs.hasOwnProperty(key)) {
      var value = attrs[key].value, m;

      if (isFunction(value) && (m = key.match(EVENT_PATTERN))) {
        host[m[1]](getEventName(m[2]), value);
        delete attrs[key];
      }
    }
  }
}

// Converts `Show` to `show` and `ChangeTitle` to `change:title`
function getEventName(name) {
  var m = name.match(EVENT_NAME_PATTERN);
  var ret = m[1] ? 'change:' : '';
  ret += m[2].toLowerCase() + m[3];
  return ret;
}


function setSetterAttrs(host, attrs, config) {
  var options = { silent: true };
  host.__initializingAttrs = true;

  for (var key in config) {
    if (config.hasOwnProperty(key)) {
      if (attrs[key].setter) {
        host.set(key, config[key], options);
      }
    }
  }

  delete host.__initializingAttrs;
}


var ATTR_SPECIAL_KEYS = ['value', 'getter', 'setter', 'readOnly'];

// normalize `attrs` to
//
//   {
//      value: 'xx',
//      getter: fn,
//      setter: fn,
//      readOnly: boolean
//   }
//
function normalize(attrs, isUserValue) {
  var newAttrs = {};

  for (var key in attrs) {
    var attr = attrs[key];

    if (!isUserValue &&
        isPlainObject(attr) &&
        hasOwnProperties(attr, ATTR_SPECIAL_KEYS)) {
      newAttrs[key] = attr;
      continue;
    }

    newAttrs[key] = {
      value: attr
    };
  }

  return newAttrs;
}

var ATTR_OPTIONS = ['setter', 'getter', 'readOnly'];
// 专用于 attrs 的 merge 方法
function mergeAttrs(attrs, inheritedAttrs, isUserValue){
  var key, value;
  var attr;

  for (key in inheritedAttrs) {
    if (inheritedAttrs.hasOwnProperty(key)) {
      value = inheritedAttrs[key];
      attr = attrs[key];

      if (!attr) {
        attr = attrs[key] = {};
      }

      // 从严谨上来说，遍历 ATTR_SPECIAL_KEYS 更好
      // 从性能来说，直接 人肉赋值 更快
      // 这里还是选择 性能优先

      // 只有 value 要复制原值，其他的直接覆盖即可
      (value['value'] !== undefined) && (attr['value'] = cloneValue(value['value'], attr['value']));

      // 如果是用户赋值，只要考虑value
      if (isUserValue) continue;

      for (var i in ATTR_OPTIONS) {
        var option = ATTR_OPTIONS[i];
        if (value[option] !== undefined) {
          attr[option] = value[option];
        }
      }
    }
  }

  return attrs;
}

function hasOwnProperties(object, properties) {
  for (var i = 0, len = properties.length; i < len; i++) {
    if (object.hasOwnProperty(properties[i])) {
      return true;
    }
  }
  return false;
}


// 对于 attrs 的 value 来说，以下值都认为是空值： null, undefined, '', [], {}
function isEmptyAttrValue(o) {
  return o == null || // null, undefined
      (isString(o) || isArray(o)) && o.length === 0 || // '', []
      isEmptyObject(o); // {}
}

// 判断属性值 a 和 b 是否相等，注意仅适用于属性值的判断，非普适的 === 或 == 判断。
function isEqual(a, b) {
  if (a === b) return true;

  if (isEmptyAttrValue(a) && isEmptyAttrValue(b)) return true;

  // Compare `[[Class]]` names.
  var className = toString.call(a);
  if (className != toString.call(b)) return false;

  switch (className) {

    // Strings, numbers, dates, and booleans are compared by value.
    case '[object String]':
      // Primitives and their corresponding object wrappers are
      // equivalent; thus, `"5"` is equivalent to `new String("5")`.
      return a == String(b);

    case '[object Number]':
      // `NaN`s are equivalent, but non-reflexive. An `equal`
      // comparison is performed for other numeric values.
      return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);

    case '[object Date]':
    case '[object Boolean]':
      // Coerce dates and booleans to numeric primitive values.
      // Dates are compared by their millisecond representations.
      // Note that invalid dates with millisecond representations
      // of `NaN` are not equivalent.
      return +a == +b;

    // RegExps are compared by their source patterns and flags.
    case '[object RegExp]':
      return a.source == b.source &&
          a.global == b.global &&
          a.multiline == b.multiline &&
          a.ignoreCase == b.ignoreCase;

    // 简单判断数组包含的 primitive 值是否相等
    case '[object Array]':
      var aString = a.toString();
      var bString = b.toString();

      // 只要包含非 primitive 值，为了稳妥起见，都返回 false
      return aString.indexOf('[object') === -1 &&
          bString.indexOf('[object') === -1 &&
          aString === bString;
  }

  if (typeof a != 'object' || typeof b != 'object') return false;

  // 简单判断两个对象是否相等，只判断第一层
  if (isPlainObject(a) && isPlainObject(b)) {

    // 键值不相等，立刻返回 false
    if (!isEqual(keys(a), keys(b))) {
      return false;
    }

    // 键相同，但有值不等，立刻返回 false
    for (var p in a) {
      if (a[p] !== b[p]) return false;
    }

    return true;
  }

  // 其他情况返回 false, 以避免误判导致 change 事件没发生
  return false;
}
```

## 源码分析
`Attribute`模块中，几个工具函数比较高端，很多方法采用了jQuery的方法。
### `isPlainObject`
首先是`isPlainObject`方法，这个方法是用来检测一个对象是否为纯粹的对象的。所谓纯粹对象就是对象是由对象字面量`{}`直接创建，或是由`Object()`构造函数创造的。我们知道JS中一切皆对象，但像`Function`或者是由自定义的类作为构造函数创建的对象就不是纯粹对象。
``` javascript
function isPlainObject(o) {
  if (!o || toString.call(o) !== "[object Object]" ||
      o.nodeType || isWindow(o)) {
    return false;
  }

  try {
    if (o.constructor &&
        !hasOwn.call(o, "constructor") &&
        !hasOwn.call(o.constructor.prototype, "isPrototypeOf")) {
      return false;
    }
  } catch (e) {
    return false;
  }

  var key;

  // Support: IE<9
  // Handle iteration over inherited properties before own properties.
  // http://bugs.jquery.com/ticket/12199
  if (iteratesOwnLast) {
    for (key in o) {
      return hasOwn.call(o, key);
    }
  }

  // Own properties are enumerated firstly, so to speed up,
  // if last one is own, then all properties are own.
  for (key in o) {}

  return key === undefined || hasOwn.call(o, key);
}
```
方法的前半部分进行了一些非纯粹对象的检测，第一个if语句排除了可转换为false的对象，`Object.prototype.toString.call(obj)`返回不是`[object Object]`的对象，DOM和window对象。经过第一个if语句的都至少是对象了。

第二个if语句用来检测对象是否由`Object()`创建，如果几个条件都满足，则不是由构造函数`Object()`创建，而是由自定义的构造函数创建：
 1. obj含有属性`constructor`，所有通过构造函数创建的对象都有这个属性，如果没有，则说明是通过对象字面量直接创建的。
 2. 对象obj的属性`constructor`是非继承属性。默认情况下，属性`constructor`继承自构造函数的原型对象。如果属性`constructor`是非继承属性，说明该属性已经在自定义构造函数中被覆盖。
 3.对象obj的原型对象中没有属性`isPrototypeOf`。属性`isPrototypeOf`是Object原型对象的特有属性，如果对象obj的原型对象中没有，说明不是由构造函数`Object()`创建，而是由自定义构造函数创建。

后面的一个if语句是jQuery中针对IE<9的版本修复的一个bug。原来的逻辑是执行for-in循环时，会先枚举非继承属性，再枚举继承属性，因此，如果最后一个属性是非继承属性，则所有属性都是非继承属性，返回`true`。但是在IE<9中，继承属性会在非继承属性之前被枚举出来，因此通过之前的一步检测，将枚举特性保存在`iteratesOwnLast`属性中进行特别处理，即遍历时，如果第一个枚举出来的属性就是非继承属性，则所有属性都是非继承属性，返回`true`。

## 参考资料
jquery技术内幕